// №1. Создать очередь из целых чисел. Выполнить циклический сдвиг очереди так, чтобы на первом месте был первый четный элемент.

// 13  1 3 5 2 5 1 4 5 3 4 5 2 1

#include<iostream>
#include <cmath>
using namespace std;

// описание структуры очереди
struct queue{
    int inf;
    queue *next;
};

// функция добавления элемента в очередь
void push(queue *&h, queue *&t, int x){
    queue *r = new queue;
    r->inf = x;
    r->next = NULL;         // всегда последний
    if (!h && !t){          // если очередь пуста, то это и голова, и хвост
        h = t = r;
    }
    else{                   // если очередь не пуста, то 
        t->next = r;        // r - следующий для хвоста
        t = r;              // теперь r - хвост
    }
}

// функция удаления элемента (и возвращения его значения)
int pop(queue*& h, queue *&t){ 
    queue *r = h;                   // создаем указатель на голову
    int i = h->inf;                 // сохраняем значение головы
    h = h->next;                    // сдвигаем указатель на следующий элемент
    if (!h)                    // если удаляем последний элемент из очереди
        t = NULL;
    delete r;                  // удаляем первый элемент
    return i;
}

// функция, возвращающая результат
void result(queue*&h, queue *&t){
    queue *h_res = NULL, *t_res = NULL;       // результирующая очередь
    queue *head1 = NULL, *tail1 = NULL;       // вспомогательная очередь 1
    queue *head2 = NULL, *tail2 = NULL;       // вспомогательная очередь 2

    int x, count = 0;
    bool flag = true;
    
    while (h && t){                           // идем по изначальной очереди и считаем количество элементов до первого четного
        x = pop(h, t);
        if (x % 2 && flag) count++;           // считаем количество нечетных
        if (!(x % 2)) flag = false;           // если наткнулись на четный - присваиваем флагу значение false
        push(head1, tail1, x);
    }
    h = head1, t = tail1;                     // переобозначаем указатели


    int count_new = 0;
    while (h && t){
        x = pop(h, t);
        if (count_new < count) push(head2, tail2, x);   // если новый счетчик < номера первого четного элемента, добавляем
                                                        // элементы с этими номерами во вспомогательную очередь 2
        else push(h_res, t_res, x);   // если же мы смотрим на элементы после первого четного, добавляем их сразу в результирующую очередь
        count_new++;
    }
    h = head2, t = tail2;                     // переобозначаем указатели


    while (h && t){                     // проходим по вспомогательной очереди 2 и перебрасываем
                                        // элементы из нее в результирующую очередь
        x = pop(h, t);
        push(h_res, t_res, x);
    }
    h = h_res, t = t_res;               // переобозначаем указатели
}

int main(){
    int n; cout << "n = "; cin >> n;            // размерность очереди
    queue* head = NULL, *tail = NULL;           // инициализация очереди
    int x;
    for (int i = 0; i < n; i++) {               // заполнение очереди 
        cin >> x;
        push(head, tail, x);
    }

    result(head, tail); 

    while (head && tail)                        // пока очередь не пуста      
        cout << pop(head, tail) << " ";         // вывод результатов на экран
    cout << endl;
}