// №4. Создать стек, содержащий целые числа. После  всех максимальных чисел вставить минимальное число. Порядок следования в результате должен совпадать с порядком следования ввода.

#include <iostream>
using namespace std;


// описание структуры стека
struct stack{
    int inf;
    stack *next;
};

// функция добавления элемента в стек
void push(stack *&h, int x){
    stack *r = new stack;       // создание нового элемента
    r->inf = x;                 // поле inf (значение) = х
    r->next = h;                // следующим элементом является h
    h = r;                      // теперь r является головой
}

// функция удаления элемента (и возвращения его значения)
int pop(stack *&h){
    int i = h->inf;             // значение первого элемента
    stack *r = h;               // указатель на голову стека
    h = h->next;                // переносим указатель на следующий элемент
    delete r;                   // удаляем первый элемент
    return i;                   // возвращаем его значение
}

// функция, переписывающая элементы в новый стек в нужном порядке
void reverse(stack *&h){
    stack *head1 = NULL;        // инициализация буферного стека
    while (h)                   // пока стек не пуст
        push(head1, pop(h));    // переписываем из одного стека в другой
    h = head1;                  // переобозначаем указатели
}

// функция, возвращающая результат
stack *result(stack *&h){
    stack *res = NULL;          // результирующий стек
    stack *help = NULL;         // вспомогательный стек

    int x = pop(h);
    int min = x, max = x;       // берем за минимум и максимум первый элемент
    push(help, x);              // записываем его во вспомогательный стек
    
    while (h){
        x = pop(h);             // удаляем первый элемент из head и записываем значение в x
        push(help, x);          // вставляем элемент x в во вспомогательный стек
        if (x < min) min = x;   // определяем минимум и максимум
        if (x > max) max = x;        
    }
    reverse(help);              // переворачиваем вспомогательный стек
    h = help;                   

    while(h){
        x = pop(h);
        push(res, x);                       // теперь переносим элементы в результирующий стек
        if (x == max) push(res, min);       // после всех максимальных вставляем минимальный
    }
    reverse(res);               // переворачиваем результирующий стек
    return res;
}

int main(){
    stack *head = NULL;                 // инициализация стека
    int n; cout << "n = "; cin >> n;    // размерность стека
    int x;
    for (int i = 0; i < n; i++){        // создание стека
        cin >> x;
        push(head, x);
    }
    reverse(head);                      // переворачиваем стек
    stack *res = result(head);          // конечный результат

    while (res)                         // пока стек непустой
        cout << pop(res) << " ";        // вывод результатов на экран
    cout << endl;
    return 0;
}