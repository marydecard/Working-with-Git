\documentclass[referat]{SCWorks}

\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage[sort,compress]{cite}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{fancyvrb}
\usepackage{longtable}
\usepackage{array}
\usepackage[english,russian]{babel}
\usepackage{minted}
\usepackage{tempora}
\usepackage[hidelinks]{hyperref}

\begin{document}

\tableofcontents

\section{Управление памятью на основе регионов}
\subsection{Мотивировка}
Текущая реализация абстрактного синтаксического дерева имеет следующие недостатки:
\begin{enumerate}
    \item Выделение памяти стандартным методом может значительно фрагментировать оперативную память, затрудняя доступ к ней.
    \item Любое выделение и удаление памяти требует вмешательства системных
    вызовов, что может стать причиной дополнительных издержек во время работы программы.
    \item Программист не имеет возможности ручного управления выделяемой им памятью.
\end{enumerate}

Избавиться от этих недостатков можно используя различные оптимизации. В рамках этой работы воспользуемся управлением памятью на основе, так называемых, регионов (арен, зон)\cite{Princeton}.

Под регионом далее будем понимать непрерывную область памяти, содержащую внутри себя объекты. При запуске программы выделим регион некоторого размера, при необходимости увеличивая его размер в некоторое постоянное
число раз.

Этот подход имеет следующие преимущества:
\begin{enumerate}
    \item Элементы располагаются последовательно, в связи с чем минимизируется фрагментация и упрощается доступ к объектам.
    \item Выделение и освобождение памяти выполняется с минимальными издержками.
    \item Программисту предоставляется большая свобода для управления выделенной памятью.
\end{enumerate}

\subsection{Построение}
Формально определим требования к системе:
\begin{enumerate}
    \item Регион должен представлять из себя некоторый непрерывный участок размера $n$ байт (в начальный момент времени размер равен некоторой начальной величине $n_0$).
    \item При обращении к региону он должен предоставить $k$ байт памяти и вернуть некоторый идентификатор этого участка для последующего обращения.
    \item При заполнении региона должна быть возможность увеличить объем доступной памяти в некоторое число раз, которое далее будем называть коэффициентом увеличения.
    \item Должна быть доступна возможность эффективного освобождения всей выделенной регионом памяти.
\end{enumerate}

Единственной сложной операцией над регионом является его увеличение. Так как выделение нового участка потенциально может сопровождаться изменением адресов объектов, то необходимо организовать доступ к ним независимо от первоначального адреса. Для этого для каждого объекта будем получать доступ к нему через некоторый индекс.

Кроме того, коэффициент увеличения должен быть выбран таким образом, чтобы был соблюден баланс между оптимальным объемом выделенной памяти и частотой системных вызовов.

\subsection{Определение структуры}
Определим нашу структуру следующим образом:

\begin{minted}[fontsize=\small, breaklines=true, style=bw, linenos]{cpp}
typedef struct arena {
    // Указатель на начало региона
    struct node* arena;
    // Размер региона
    unsigned int size;
    // Объем выделенной регионом памяти
    unsigned int allocated;
} arena;
\end{minted}

\subsection{Инициализация}
Теперь определим функцию \verb|arena_construct|, выполняющую начальную инициализацию состояния региона:

\begin{minted}[fontsize=\small, breaklines=true, style=bw, linenos]{cpp}
int arena_construct (arena* arena) {
    // Начальный размер региона равен некоторой постоянной, равной DEFAULT_ARENA_SIZE
    arena->size = DEFAULT_ARENA_SIZE;
    arena->allocated = 0;
    // Выделим необходимое число памяти
    arena->arena = malloc(sizeof(node) * DEFAULT_ARENA_SIZE);
    // Если выделение прошло неудачно - вернем в качестве кода ошибки отличное от 0 значение.
    if (arena->arena == NULL) {
        return (!0);
    }
    return 0;
}
\end{minted}

\subsection{Выделение памяти}
После выделения некоторого объема памяти возможно обращение к ней. Определим это обращение с помощью функции \verb|arena_allocate|:

\begin{minted}[fontsize=\small, breaklines=true, style=bw, linenos]{cpp}
int arena_allocate (arena* arena, unsigned int count) {
    // Если места в регионе недостаточно
    if (arena->allocated + count >= arena->size) {
        // Определим новый размер региона
        unsigned int newSize = MULTIPLY_FACTOR * arena->size;
        // Выделим регион большего размера и освободим ранее занятую память
        node* newArena = realloc(arena->arena, 
            newSize  * sizeof(node));
        if (NULL == newArena) {
            return -1;
        }
        arena->arena = newArena;
        arena->size = newSize;
    }
    // В качестве результата вернем индекс первого свободного участка региона
    unsigned int result = arena->allocated;
    // Сместим индекс на объем выделенной памяти
    arena->allocated += count;
    // Вернем результат
    return result;
}
\end{minted}
Отметим, что наиболее часто значением \verb|MULTIPLY_FACTOR| оказываются числа $1.5$ и $2$. Это позволяет достичь амортизационно константного времени выполнения операции выделения памяти \cite{Facebook}.

\subsection{Освобождение выделенной памяти}
Наконец, реализуем освобождение выделенной региону памяти с помощью функции \verb|arena_free|

\begin{minted}[fontsize=\small, breaklines=true, style=bw, linenos]{cpp}
void arena_free (arena* arena) {
    if (arena->arena != NULL)
        free(arena->arena);
    arena->arena = NULL;
}
\end{minted}

\subsection{Модификация абстрактного синтаксического дерева}
Осталось изменить исходный код программы, чтобы обеспечить выделение памяти с помощью полученной нами структуры данных.

Для этого воспользуемся директивой \verb|%param| и заявим в качестве параметра переменную типа \verb|arena*|. В функциях \verb|eval|, \verb|newnum|, \verb|newast| внесем изменения, чтобы обеспечить выделение памятью с помощью написанных ранее функций.

С полным кодом программы можно ознакомиться в приложении \ref{app:Flash"=носитель}.

\subsection{Сборка проекта}
Теперь проект можно собрать, незначительно изменив \verb|Makefile|:

\inputminted[fontsize=\small, breaklines=true, style=bw, linenos]{cpp}{Makefile}

\noindent и запустить. Результат работы программы представлен на рис. \ref{fig:Демонстрация работы программы}

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.5]{naivetest.png}
    \caption{Демонстрация работы программы}
    \label{fig:Демонстрация работы программы}
\end{figure}

\section{Сравнение полученных результатов}
Проведем анализ производительности полученных версий анализатора. В качестве данных для тестирования возьмем выражения вида $\underbrace{2 + 2 + 2\dots+ 2}_{n}$ для $n = 1\dots100$ с шагом $1$. Для вычисления времени выполнения воспользуемся библиотекой \verb|time| Python 3.9.5. Автоматизацию обеспечим с помощью библиотеки \verb|subprocess|. Получим следующий код:

\inputminted[fontsize=\small, breaklines=true, style=bw, linenos]{python3}{test.py}

Кроме того, отметим, что в ранее написанные программы были внесены некоторые изменения для проведения эксперимента. Ознакомиться с ними можно в приложении \ref{app:Flash"=носитель}.

Ознакомиться с полным исходным кодом программы, осуществляющей исследование производительности можно в приложении \ref{app:Исследование производительности}.

Для большей наглядности графики интерполированы полиномом с помощью функции \verb|polyfit| библиотеки \verb|numpy|.

Ознакомиться с полным исходным кодом программы, осуществляющей анализ полученных результатов можно в приложении \ref{app:Анализ результатов}.

Результаты исследования изображены на рис. \ref{fig:Сравнение полученных результатов}:
\begin{figure}[H]
    \centering
    \includegraphics[scale=0.5]{benchmark.png}
    \caption{Сравнение полученных результатов}
    \label{fig:Сравнение полученных результатов}
\end{figure}

Исследование показало, что использование абстрактных синтаксических деревьев позволяет уменьшить время работы программы более чем в $5$ раз, что существенно заметно для выражений любой длины.

Также из графиков видно, что в рамках данной работы не удалось добиться большей производительности при управлении памятью на основе регионов. Тем не менее, она все еще может считаться более предпочительной ввиду перечисленных ранее преимуществ.


\conclusion
В ходе данной работы:
\begin{enumerate}
    \item Были изучены теоретические основы построения лексических и синтаксических анализаторов
    \item Проанализированы особенности реализации лексических и синтаксических анализаторов
    \item Были изучены принципы работы генераторов лексического и синтаксического анализа на примере Flex и GNU Bison.
    \item Были созданы лексический и синтаксический анализаторы для анализа математического выражения.
    \item Было изучено понятие абстрактного синтаксического дерева.
    \item Проведен анализ производительности полученных реализаций.
\end{enumerate}

Таким образом, все поставленные в рамках работы задачи выполнены.

Результаты исследования показали, что абстрактные синтаксические деревья позволяют добиться увеличения производительности в $5$--$6$ раз.

А это, в свою очередь, позволяет утверждать о том, что концепция абстрактных синтаксических деревьев является крайне важной в информатике и ее приложениях, в частности, при создании синтаксических анализаторов.

% Меняем inputencoding на лету, чтобы работать с библиографией в кодировке
% `cp1251', в то время как остальной документ находится в кодировке `utf8'
% Credit: Никита Рыданов
\inputencoding{cp1251}
\bibliographystyle{gost780uv}
\bibliography{thesis}
\inputencoding{utf8}

\appendix
\section{Flash"=носитель с исходным кодом программ, использующихся в работе}
\label{app:Flash"=носитель}

\noindent \textbf{Папка} \verb|src| содержит оригинальный исходный код программы:

\textbf{Папка} \verb|naive| "--- реализация без АСД

\textbf{Папка} \verb|naiveast|  "--- реализация с АСД

\textbf{Папка} \verb|arena| "--- реализация с АСД на основе региона


\noindent \textbf{Папка} \verb|extsrc| измененный исходный код, необходимый для исследования производительности:

\textbf{Папка} \verb|naive| "--- реализация без АСД

\textbf{Папка} \verb|naiveast|  "--- реализация с АСД

\textbf{Папка} \verb|arena| "--- реализация с АСД на основе региона


\section{Исходный код программы на Python, осуществляющей исследование
производительности полученных реализаций}
\label{app:Исследование производительности}

\inputminted[fontsize=\small, breaklines=true, style=bw, linenos]{python3}{test.py}

\section{Исходный код программы на Python, осуществляющей анализ
полученных результатов}
\label{app:Анализ результатов}

\inputminted[fontsize=\small, breaklines=true, style=bw, linenos]{python3}{graph.py}

\end{document}